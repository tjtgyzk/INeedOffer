> 事务是逻辑上的一组操作，要么都执行，要么都不执行。

# 事务的特性（ACID）

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206211643920.png)

1. **原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保**动作要么全部完成，要么完全不起作用**；
2. **一致性：** **执行事务前后，数据保持一致**，例如转账业务中，无论事务是否成功，转账者和收款人的**总额应该是不变的**；
3. **隔离性：** 并发访问数据库时，**一个用户的事务不被其他事务所干扰**，各**并发事务之间数据库是独立**的；
4. **持久性：** 一个事务被提交之后。它对数据库中**数据的改变是持久的**，即使**数据库发生故障也不应该对其有任何影响**。

## 并发事务带来的问题

- **脏读（Dirty read）-- 使用了还未提交的数据 :** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）-- 同时修改同一个数据 :** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
- **不可重复读（Unrepeatableread）-- 多次读取数据不一致 :** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）-- 多出一些数据/丢失一些数据 :** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在**随后的查询**中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**不可重复度和幻读区别：**

不可重复读的重点是**修改**，幻读的重点在于**新增或者删除**。

# 事务的隔离级别

**SQL 标准定义了四个隔离级别：**

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：
  - **快照读** ：由 MVCC 机制来保证不出现幻读。
  - **当前读** ： 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| READ-UNCOMMITTED |  √   |     √      |  √   |
|  READ-COMMITTED  |  ×   |     √      |  √   |
| REPEATABLE-READ  |  ×   |     ×      |  √   |
|   SERIALIZABLE   |  ×   |     ×      |  ×   |

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看，MySQL 8.0 该命令改为`SELECT @@transaction_isolation;`

# MVCC

> MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

- 多版本并发控制（MVCC）是一种用来解决**读-写冲突**的**无锁并发控制**，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，**版本与事务时间戳关联**，读操作只读**该事务开始前的数据库的快照**。 所以MVCC可以为数据库解决以下问题

- 在并发读写数据库时，可以做到在**读操作时不用阻塞写操作**，**写操作也不用阻塞读操作**，提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但**不能解决更新丢失问题**

## 当前读和快照读

- 当前读

它读取的是记录的**最新版本**，读取时还要**保证其他并发事务不能修改当前记录**，会对**读取的记录进行加锁**

- 快照读

像**不加锁**的select操作就是快照读，即不加锁的**非阻塞读**；快照读的前提是**隔离级别不是串行级别**，串行级别下的快照读会退化成当前读。之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是**基于多版本并发控制**，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的**并不一定是数据的最新版本**，而**有可能是之前的历史版本**

> 说白了**MVCC就是为了实现读-写冲突不加锁**，而这个读指的就是**快照读**, 而非当前读，当**前读实际上是一种加锁的操作，是悲观锁的实现**

 

## MVCC的实现

`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。

- 在内部实现中，`InnoDB` 通过数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。
- 每个事务读到的数据版本可能是不一样的，在同一个事务中，用户**只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改**

### 隐藏字段

在内部，`InnoDB` 存储引擎为每行数据添加了三个 [隐藏字段open in new window](https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html)：

- `DB_TRX_ID（6字节）`：表示**最后一次插入或更新该行的事务 id**。此外，`delete` 操作在内部被视为更新，只不过会在记录头 `Record header` 中的 `deleted_flag` 字段将其标记为已删除
- `DB_ROLL_PTR（7字节）` **回滚指针**，指向该行的 `undo log` 。如果该行未被更新，则为空
- `DB_ROW_ID（6字节）`：如果**没有设置主键**且该表**没有唯一非空索引**时，`InnoDB` 会使用该 id 来**生成聚簇索引**

### ReadView

```sql
class ReadView {
  /* ... */
private:
  trx_id_t m_low_limit_id;      /* 大于等于这个 ID 的事务均不可见 */

  trx_id_t m_up_limit_id;       /* 小于这个 ID 的事务均可见 */

  trx_id_t m_creator_trx_id;    /* 创建该 Read View 的事务ID */

  trx_id_t m_low_limit_no;      /* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */

  ids_t m_ids;                  /* 创建 Read View 时的活跃事务列表 */

  m_closed;                     /* 标记 Read View 是否 close */
}
```

- `ReadView`主要是用来做**可见性判断**，里面保存了 “当前**对本事务不可见的其他活跃事务**”

主要有以下字段：

- `m_low_limit_id`：目前**出现过的最大的事务 ID+1**，即**下一个将被分配的事务 ID**。大于等于这个 ID 的数据版本**均不可见**
- `m_up_limit_id`：**活跃事务列表** `m_ids` 中**最小的事务 ID**，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 ID 的**数据版本**均**可见**
- `m_ids`：`Read View` 创建时**其他未提交的活跃事务 ID 列表**。创建 `Read View`时，将**当前未提交事务 ID 记录下来**，后续即使它们修改了记录行的值，对于当前事务也是**不可见**的。`m_ids` **不包括当前事务和已提交的事务**
- `m_creator_trx_id`：创建该 `Read View` 的**事务 ID**

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206211810199.png)

### undo log

`undo log` 主要有两个作用：

- 当事务回滚时用于**将数据恢复到修改前的样子**
- 另一个作用是 `MVCC` ，当读取记录时，若**该记录被其他事务占用**或**当前版本对该事务不可见**，则可以通过 `undo log` **读取之前的版本数据**，以此实现非锁定读

**在 `InnoDB` 存储引擎中 `undo log` 分为两种： `insert undo log` 和 `update undo log`：**

1. **`insert undo log`** ：指在 `insert` 操作中产生的 `undo log`。因为 `insert` 操作的记录只对事务本身可见，对其他事务不可见，故该 `undo log` **可以在事务提交后直接删除**。不需要进行 `purge` 操作

2. **`update undo log`** ：`update` 或 `delete` 操作中产生的 `undo log`。该 `undo log`可能需要提供 `MVCC` 机制，因此**不能在事务提交时就进行删除**。提交时放入 `undo log` 链表，等待 `purge线程` 进行最后的删除

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206211826821.png)

### 数据可见性算法

当用户在这个事务中要读取某个记录行的时候，`InnoDB` 会将该记录行的 `DB_TRX_ID` 与 `Read View` 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件

1. 如果记录 DB_TRX_ID < m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）**在当前事务创建快照之前就提交了**，所以该记录行的值对当前事务是**可见**的
2. 如果 DB_TRX_ID >= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）**在当前事务创建快照之后才修改该行**，所以该记录行的值对当前事务**不可见**。跳到步骤 5
3. m_ids 为空，则表明在当前事务**创建快照之前，修改该行的事务就已经提交**了，所以该记录行的值对当前事务是**可见的**
4. 如果 m_up_limit_id <= DB_TRX_ID < m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）
   - 如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务**创建快照前**，该记录行的值被事务 ID 为 DB_TRX_ID 的事务**修改了**，但**没有提交**；或者 ② 在当前事务**创建快照后**，该记录行的值被事务 ID 为 DB_TRX_ID 的事务**修改了**。这些情况下，这个记录行的值对当前事务都是**不可见**的。跳到步骤 5
   - 在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，**在“当前事务”创建快照前就已经提交了**，所以记录行对当前事务**可见**
5. 在该记录行的 DB_ROLL_PTR 指针所指向的 **`undo log` 取出快照记录**，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到**满足的快照版本或返回空**

## RC和RR隔离级别下MVCC的差异

在事务隔离级别 `RC` 和 `RR` （InnoDB 存储引擎的默认事务隔离级别）下，`InnoDB` 存储引擎使用 `MVCC`（非锁定一致性读），但它们生成 `Read View` 的时机却不同

- 在 RC 隔离级别下的 **`每次select`** 查询前都生成一个`Read View` (m_ids 列表)
- 在 RR 隔离级别下只在事务开始后 **`第一次select`** 数据前生成一个`Read View`（m_ids 列表）

# MVCC+Next-key-Lock防止幻读

`InnoDB`存储引擎在 RR 级别下通过 `MVCC`和 `Next-key Lock` 来解决幻读问题：

**1、执行普通 `select`，此时会以 `MVCC` 快照读的方式读取数据**

在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 `Read View` ，并使用至事务提交。所以在生成 `Read View` 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”

**2、执行 select...for update/lock in share mode、insert、update、delete 等当前读**

在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！

`InnoDB` 使用 Next-key Lock 来防止这种情况。**当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。**只要我**不让你插入**，就不会发生幻读