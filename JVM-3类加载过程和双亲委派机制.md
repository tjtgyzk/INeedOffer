# 一、类加载过程

- 类的生命周期

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206180140696.png)

其中类加载的过程包括了`加载`、`验证`、`准备`、`解析`、`初始化`五个阶段。

在这五个阶段中，`加载`、`验证`、`准备`和`初始化`这四个阶段发生的顺序是确定的，*而`解析`阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)*。

另外注意这里的几个阶段是**按顺序开始**，而**不是按顺序进行或完成**，因为这些阶段通常都是**互相交叉地混合进行**的，通常在一个阶段执行的过程中调用或激活另一个阶段。

## 加载

类加载过程的第一步，主要完成下面 3 件事情：

1. 通过全类名获取**定义此类的二进制字节流**
2. 将字节流所代表的**静态存储结构**转换为方法区的**运行时数据结构**
3. 在内存中生成一个代表该类的 `Class` 对象，作为**方法区这些数据的访问入口**

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206180152013.png)

- **一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。**
- 虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如："通过全类名获取定义此类的二进制字节流" 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 `ZIP` 包中读取（日后出现的 `JAR`、`EAR`、`WAR` 格式的基础）、其他文件生成（典型应用就是 `JSP`）等等。

## 连接

### 验证

验证是**连接阶段的第一步**，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作:

- `文件格式验证`: 验证字节流是否符合Class文件格式的规范；例如: 是否以`0xCAFEBABE`开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- `元数据验证`: 对字节码描述的信息进行语义分析(注意: 对比`javac`编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了`java.lang.Object`之外。
- `字节码验证`: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- `符号引用验证`: 确保解析动作能正确执行。

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206180229698.png)

### 准备

- 准备阶段是正式**为类变量分配内存**并**设置类变量初始值**的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

  - 这时候进行内存分配的**仅包括类变量**（ Class Variables ，即**静态变量**，被 `static` 关键字修饰的变量，只与类相关，因此被称为类变量），而**不包括实例变量**。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
  - 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的**字符串常量池、静态变量等**移动到**堆**中，这个时候**类变量则会随着 Class 对象一起存放在 Java 堆**中。
  - 这里所设置的初始值"通常情况"下是**数据类型默认的零值**（如 0、0L、null、false 等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就**是 0 而不是 111**（**初始化阶段才会赋值**）。**特殊情况**：比如给 value 变量加上了 **final 关键字**`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。
  - 基本数据类型的零值：

  ![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206180232350.png)

### 解析

- 解析阶段是虚拟机**将常量池内的符号引用替换为直接引用**的过程。
- **符号引用**就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
- 解析动作主要针对**类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符** 7 类符号引用进行。

## 初始化

初始化，为类的**静态变量**赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:

- 声明类变量时指定初始值
- 使用静态代码块为类变量指定初始值

**JVM初始化步骤**

- 假如这个类还没有被加载和连接，则程序先**加载并连接**该类
- 假如该类的直接父类还没有被初始化，则**先初始化其直接父类**
- 假如类中有初始化语句，则系统**依次执行这些初始化语句**

**类初始化时机**: 只有当对类的**主动使用的时候才会导致类的初始化**，类的主动使用包括以下六种:

- **创建类的实例**，也就是new的方式
- **访问某个类或接口的静态变量**，或者**对该静态变量赋值**
- 调用类的**静态方法**
- **反射**(如Class.forName("com.pdai.jvm.Test"))
- **初始化某个类的子类，则其父类也会被初始化**
- Java虚拟机启动时被标明为**启动类**的类(Java Test)，直接使用java.exe命令来运行某个主类

## 卸载

卸载类即该类的 Class 对象被 GC。

卸载类需要满足 3 个要求:

1. 该类的**所有的实例对象都已被 GC**，也就是说堆不存在该类的实例对象。
2. 该类**没有在其他任何地方被引用**
3. 该类的**类加载器的实例已被 GC**

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们**自定义的类加载器加载的类是可能被卸载**的。

只要想通一点就好了，jdk 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

# 二、类加载器

- 所有的类都由类加载器加载，加载的作用就是将 `.class`文件加载到内存。

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。
3. **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:

- 在执行非置信代码之前，自动验证数字签名。
- 动态地创建符合用户特定需要的定制化构建类。
- 从特定的场所取得java class，例如数据库中和网络中。

## 双亲委派模型

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206181800115.png)

- 每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 **双亲委派模型** 。
- 在类加载的时候，系统会**首先判断**当前类**是否被加载过**。已经被加载的类会直接返回，否则才会尝试加载。
- 加载的时候，首先会把该请求**委派给父类加载器**的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。**当父类加载器无法处理时，才由自己来处理。**当父类加载器为 null 时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。



### 双亲委派模型优势

- 双亲委派模型保证了 Java 程序的稳定运行，可以**避免类的重复加载**（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也**保证了 Java 的核心 API 不被篡改**。
- 如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

### 打破双亲委派模型

- 自定义加载器的话，需要**继承** `ClassLoader` 。如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可**，无法被父类加载器加载的类最终会通过这个方法被加载**。
- 但是，如果想**打破双亲委派模型**则需要重写 `loadClass()` 方法

#### TomCat打破双亲委派机制

- 在部署项目时，将war包放到tomcat的webapp下，这意味着一个Tomcat可以运行多个Web应用程序
- 如果两个Web应用程序有同一个类User，且全限定名一致，但具体实现不同，则**Tomcat会给每个Web应用创建一个类加载器实例**（WebAppClassLoader），其中重写了loadClass方法，优先加载当前应用目录下的类，如果没有再一层一层往上找，做到了**Web应用层级的隔离**。
- 并不是Web应⽤程序下的所有依赖都需要隔离的，⽐如Redis就可以Web应⽤程序之 间共享（如果有需要的话），因为如果版本相同，没必要每个Web应⽤程序都独⾃加载⼀份。Tomcat就在WebAppClassLoader上加了个**⽗类加载器** （SharedClassLoader），如果WebAppClassLoader**⾃身没有加载到某个类，那就委托 SharedClassLoader去加载**。就是**把应⽤程序之间需要共享的类放到⼀个共享⽬录下**
- 为了**隔绝Web应⽤程序与Tomcat本身的类**，⼜有类加载器(CatalinaClassLoader)来 装载Tomcat本身的依赖。
- 如果Tomcat**本身的依赖和Web应⽤还需要共享**，那么还有类加载器 (CommonClassLoader)来装载进⽽达到共享。

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206190009211.png)

#### JDBC是否打破？

- JDBC定义了接⼝，具体实现类由各个⼚商进⾏实现
- 类加载有个规则：**如果⼀个类由类加载器A加载，那么这个类的依赖类也是由「相同 的类加载器」加载**。
- JDBC是使⽤DriverManager进⽽获取Connection，DriverManager 在java.sql包下，显然是由BootStrap类加载器进⾏装载
- 当我们使⽤DriverManager.getConnection()时，得到的⼀定是⼚商实现的类，但BootStrap ClassLoader加载不到各个⼚商实现的类。
- DriverManager的解决⽅案是在DriverManager初始化的时候，得到「**线程上下⽂加载器**」
- 去获取Connection的时候，是使⽤「线程上下⽂加载器」去加载Connection的，⽽ 这⾥的线程上下⽂加载器实际上还是App ClassLoader，所以在获取Connection的时候，还是先找Ext ClassLoader和BootStrap ClassLoader，只不过这俩加载器肯定是加载不到的，**最终会由App ClassLoader进⾏加载**
- 那这种情况，有的⼈觉得破坏了双亲委派机制，因为本来明明应该是由BootStrap ClassLoader进⾏加载的，结果你来了⼀⼿「线程上下⽂加载器」，改掉了「类加载器」
- 有的⼈觉得没破坏双亲委派机制，只是改成由「线程上下⽂加载器」进⾏类加载， 但**还是遵守着：「依次往上找⽗类加载器进⾏加载，都找不到时才由⾃身加载」**。认为"原则"上是没变的。