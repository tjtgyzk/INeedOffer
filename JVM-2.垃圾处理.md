# 一、判断对象是否死亡

## 1. 引用计数法

- 给对象中添加一个**引用计数器**，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。
- **难以解决循环引用问题**。

## 2. 可达性分析算法

- 这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链。
- 当一个对象到 GC Roots **没有任何引用链相连**的话，则证明此对象是不可用的，需要被回收。

### 可作为GC Roots的对象

- 虚拟机栈(栈帧中的**本地变量表**)中引用的对象
- **本地方法栈**(Native 方法)中引用的对象
- 方法区中**类静态属性**引用的对象
- 方法区中**常量引用**的对象
- 所有被**同步锁持有**的对象

### 真的死了？

- 即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程
- 可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象**是否有必要执行 `finalize` 方法**。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。
- 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

## 3. 引用

#### 强引用

- 以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 `OutOfMemoryError` 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

#### 软引用

- 如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
- 软引用可以和一个**引用队列**（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个**软引用加入到与之关联的引用队列中。**

#### 弱引用

- 如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。
- 在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，**不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
- 弱引用可以和一个**引用队列**（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

#### 虚引用

- "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
- **虚引用主要用来跟踪对象被垃圾回收的活动**。
- **虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器**准备回收一个对象时，如果发现它还有虚引用**，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果**发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。**
- 特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

## 4. 方法区垃圾收集

- 废弃的常量
- 不再使用的类型
  - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
  - 加载该类的 `ClassLoader` 已经被回收。
  - 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
- 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的**仅仅是“可以**”，而并不是和对象一样不使用了就会必然被回收。

# 二、垃圾收集算法

## 1. 标记-清除算法

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206161810504.png)

该算法分为**“标记”**和**“清除”**阶段：

- 首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。
- 它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：
  - 标记和清除过程**效率**都不高；
  - 会产生大量不连续的**内存碎片**，导致无法给大对象分配内存。

## 2. 标记-整理算法

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206161815423.png)

- 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是**让所有存活的对象向一端移动**，然后**直接清理掉端边界以外的内存**。

## 3. 标记-复制算法

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206161816685.png)

- 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。
- 主要不足是只使用了内存的一半。
- 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为**一块较大的 Eden 空间和两块较小的 Survivor 空间**，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 **Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上**，最后**清理 Eden 和使用过的那一块 Survivor。**
- HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要**依赖于老年代进行分配担保**，也就是借用老年代的空间存储放不下的对象。

## 4. 分代收集理论

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

- **比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。**
- **老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

## 5. 内存分配策略

### 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。

### 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

`-XX:PretenureSizeThreshold`，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。

### 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

`-XX:MaxTenuringThreshold` 用来定义年龄的阈值。

### 动态对象年龄判定

虚拟机并不是永远地要求对象的年龄必须达到 `MaxTenuringThreshold` 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 `MaxTenuringThreshold` 中要求的年龄。

### 空间分配担保

在发生 Minor GC 之前，虚拟机先检查**老年代最大可用的连续空间是否大于新生代所有对象总空间**，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 `HandlePromotionFailure` 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 `HandlePromotionFailure` 设置不允许冒险，那么就要进行一次 Full GC。

## 6. Full GC的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:

- **调用 System.gc()**：只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。**不建议**使用这种方式，而是让虚拟机管理内存。
- **老年代空间不足：**老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
  - 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。
  - 除此之外，可以通过 `-Xmn` 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。
  - 还可以通过 `-XX:MaxTenuringThreshold` 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。
- **空间分配担保失败**
- （JDK1.7以前）永久代空间不足
- **Concurrent Mode Failure**（CMS中）

# 三、常见垃圾处理器

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206161831059.png)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- **单线程与多线程**: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；
- **串行与并行**: **串行**指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要**停顿用户程序**；**并行**指的是垃圾收集器和用户程序**同时执行**。**除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。**

## 1. Serial收集器

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206162003630.png)

- 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。
- 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。
- 它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。
- **新生代采用标记-复制算法，老年代采用标记-整理算法。**
- 它是 Client 模式下的**默认新生代收集器**，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。

## 2. ParNew收集器

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206162004716.png)

- 它是 Serial 收集器的多线程版本。
- 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。
- 默认开启的线程数量与 CPU 数量相同，可以使用 `-XX:ParallelGCThreads` 参数来设置线程数。

## 3.  Parallel Scavenge收集器

- 与 ParNew 一样是多线程收集器。
- **其它收集器**关注点是尽可能**缩短垃圾收集时用户线程的停顿时间**，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。
- **停顿时间**越短就越**适合需要与用户交互的程序**，良好的响应速度能提升用户体验。而**高吞吐量**则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要**适合在后台运算而不需要太多交互的任务。**
- 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: **新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。**
- **新生代采用标记-复制算法，老年代采用标记-整理算法。**

## 4. Serial Old收集器

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206162011348.png)

是 Serial 收集器的**老年代版本**，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:

- 在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

## 5. Parallel Old收集器

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206162013944.png)

- 是 Parallel Scavenge 收集器的老年代版本。

- 在**注重吞吐量**以及 **CPU 资源敏感**的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

## 6. CMS收集器

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206162138730.png)

CMS(Concurrent Mark Sweep)并发标记清除，Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程:

- **初始标记**: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，**需要停顿**。
- **并发标记**: 进行 GC Roots Tracing 的过程，它在整个回收过程中**耗时最长**，不需要停顿。
- **并发预处理**：减少下一个阶段”重新标记“需要的时间，借助类卡表的存储（将老年代对象发生变化所对应的卡页标为dirty），扫描可能由于”并发标记“导致**老年代发生变化**的对象，再扫描一遍被标记为dirty的卡页；对于新生代对象，遍历**新生代**来看看在”并发标记“过程中有没有对象**引用了老年代**，为了更少的遍历新生代对象，此处**可能会触发一次minor GC**
- **重新标记**: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，**需要停顿**。
- **并发清除**: 不需要停顿。

缺点：

- **空间需要预留**：一边回收垃圾，一边处理用户线程，需要预留足够的空间给用户使用，如果不够用，会报`Concurrent Mode Failure`，会启动Serial Old进行老年代垃圾回收，导致停顿时间变长
- **内存碎片问题**：标记清除算法导致，当碎片太多时内存不足会触发full GC进行碎片整理，消耗很长时间
- **对CPU资源比较敏感**

## 7. G1收集器

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

- G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206162153623.png)

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206162156908.png)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:

- **初始标记**
- **并发标记**
- **重新标记**: 为了修正在并发标记期间因用户程序继续运作而导致**标记产生变动**的那一部分标记记录，在GC开始的时候，它为存活的对象做了一次”快照“，在并发阶段时，把每一次发生引用关系变化时的旧的引用值记录下来，在重新标记阶段**只扫描发生过变化的引用**，如果有对象存活，加入GC Roots（这叫做SATB算法，依然可能存在浮动垃圾问题）。这阶段**需要停顿线程，但是可并行执行**。
- **筛选回收**: 首先对各个 Region 中的**回收价值和成本进行排序**，**根据用户所期望的 GC 停顿时间**来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。**一般会回收所有年轻代以及部分老年代数据**

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206162155033.png)

