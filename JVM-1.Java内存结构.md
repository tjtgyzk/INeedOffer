# 一、Java内存结构

## 运行时数据区域

> Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。
>
> 以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。

- JDK 1.8之前

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206152006260.png)

- JDK 1.8之后

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206152006544.png)

### 线程私有

- 程序计数器
- 虚拟机栈
- 本地方法栈

### 线程共享

- 堆
- 方法区
- 直接内存（非运行时数据区的一部分）

### 1.1 程序计数器

- 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的**行号指示器**。
- 在多线程的情况下，程序计数器用于**记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
- 程序计数器是唯一一个**不会出现 `OutOfMemoryError` 的内存区域**，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### 1.2 Java虚拟机栈

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206152058569.png)

#### 局部变量表

- 主要存放了编译期可知的各种**数据类型**（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
- **局部变量表所需要的容量大小是编译期确定下来的**，并保存在方法的 Code 属性的 `maximum local variables` 数据项中。在**方法运行期间不会改变**局部变量表的大小
- 方法**嵌套调用的次数**由**栈的大小**决定。一般来说，**栈越大，方法嵌套调用次数越多**。对一个函数而言，它的**参数和局部变量越多**，使得局部变量表膨胀，它的**栈帧就越大**，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，**导致其嵌套调用次数就会减少**。

- 槽（slot）
  - 局部变量表**最基本的存储单元**是 Slot（变量槽）
  - 在局部变量表中，32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot
  - JVM 会为局部变量表中的每一个 Slot 都分配一个**访问索引**，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量
  - 当一个实例方法**被调用的时候**，它的方法参数和方法体内部定义的局部变量将会**按照顺序被复制**到局部变量表中的每一个 Slot 上
  - **如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可**。（比如：访问 long 或 double 类型变量，不允许采用任何方式单独访问其中的某一个 Slot）
  - 如果当前帧是由**构造方法或实例方法**创建的，那么该对象引用 **this 将会存放在 index 为 0 的 Slot 处**，其余的参数按照参数表顺序继续排列（这里就引出一个问题：**静态方法**中为什么**不可以引用 this**，就是因为this 变量不存在于当前方法的局部变量表中）
  - **栈帧中的局部变量表中的槽位是可以重用的**，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而**达到节省资源的目的**。

#### 操作数栈

- 主要作为**方法调用的中转站**使用，用于**存放**方法执行过程中产生的**中间计算结果**。
- 计算过程中产生的**临时变量**也会放在操作数栈中。

#### 动态链接

- **每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。
- 在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为**符号引用**（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**
- ![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206152315053.png)



#### 方法返回地址

> ​        Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， **栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。**

- 用来存放**调用该方法的 PC 寄存器**的值。
- 方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。
- 而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。
- 本质上，**方法的退出就是当前栈帧出栈的过程**。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

#### 两种异常

- **`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

### 1.3 本地方法栈

> 本地方法接口：
>
> 简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。
>
> - 与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互，这就是本地方法存在的原因。
>
> - 与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的。
>
> - Sun's Java：Sun的解释器就是C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分都是用 Java 实现的，它也通过一些本地方法与外界交互。比如，类 `java.lang.Thread` 的 `setPriority()` 的方法是用Java 实现的，但它实现调用的是该类的本地方法 `setPrioruty()`，该方法是C实现的，并被植入 JVM 内部。

- 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**
- 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
- 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。
-  **在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。**

### 1.4 堆

> 对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，**被所有线程共享**。
>
> 此内存区域的唯一目的就是**存放对象实例**，几乎所有的**对象实例以及数据**都在这里分配内存。

为了进行高效的垃圾回收，虚拟机把堆内存**逻辑上**划分成三块区域（分代的唯一理由就是优化 GC 性能）：

- **新生代**：新对象和没达到一定年龄的对象都在新生代
- **老年代**：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
- **元空间**（JDK1.8 之前叫**永久代**）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206160049666.png)

#### 新生代

新生代是所有新对象创建的地方。**当Eden驱填满时，执行垃圾收集。**这种垃圾收集称为 **Minor GC**。

新生代被分为三个部分——伊甸园（**Eden Memory**）和两个幸存区（**Survivor Memory**，被称为from/to或s0/s1），默认比例是`8:1:1`

- 大多数新创建的对象都位于 Eden 内存空间中
- 当 Eden 空间**被对象填充**时，执行**Minor GC**，并将所有幸存者对象移动到一个幸存者空间中
- Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以**每次，一个幸存者空间总是空的**
- 经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的**年龄阈值**来实现的，然后他们才有资格提升到老一代

#### 老年代

- 旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在**老年代内存满**时执行的。
- 老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。

- **大对象直接进入老年代**（大对象是指需要大量连续内存空间的对象）。这样做的目的是**避免**在 Eden 区和两个Survivor 区之间发生**大量的内存拷贝**

#### 元空间

不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现。

虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开。

#### 设置堆内存大小和 OOM

Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 `-Xmx` 和 `-Xms` 来设定

- `-Xms` 用来表示堆的起始内存，等价于 `-XX:InitialHeapSize`
- `-Xmx` 用来表示堆的最大内存，等价于 `-XX:MaxHeapSize`

如果堆的内存大小超过 `-Xmx` 设定的最大内存， 就会抛出 `OutOfMemoryError` 异常。

我们通常会将 `-Xmx` 和 `-Xms` 两个参数配置为**相同的值**，其目的是为了能够在垃圾回收机制清理完堆区后**不再需要重新分隔计算堆的大小**，从而提高性能

- 默认情况下，初始堆内存大小为：电脑内存大小/64
- 默认情况下，最大堆内存大小为：电脑内存大小/4

#### 小小超纲一下

##### 什么是 TLAB （Thread Local Allocation Buffer）?

- 从内存模型而不是垃圾回收的角度，**对 Eden 区域继续进行划分**，JVM 为每个线程分配了一个**私有缓存区域**，它包含在 Eden 空间内
- 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为**快速分配策略**
- OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计

##### 为什么要有 TLAB ?

- 堆区是线程共享的，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是**线程不安全**的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度

尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。

在程序中，可以通过 `-XX:UseTLAB` 设置是否开启 TLAB 空间。

默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 `-XX:TLABWasteTargetPercent` 设置 TLAB 空间所占用 Eden 空间的百分比大小。

一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。

##### 堆是分配对象存储的唯一选择吗

- 逃逸分析
  - **逃逸分析(Escape Analysis)是目前 Java 虚拟机中比较前沿的优化技术。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法**。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
  - 当一个对象在方法中被定义后，对象**只在方法内部使用**，则认为**没有发生逃逸**。
  - 当一个对象在方法中被定义后，它被**外部方法所引用**，则认为**发生逃逸**。例如作为调用参数传递到其他地方中，称为方法逃逸。

- 使用逃逸分析，编译器可以对代码做优化：
  - **栈上分配**：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配
  - **同步省略**：如果一个对象被发现**只能从一个线程被访问到**，那么对于这个对象的操作**可以不考虑同步**
  - **分离对象或标量替换**：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器

### 1.5 方法区

- 方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个**线程共享**的内存区域。
- 当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再**将信息存入到方法区**。

- 方法区会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206160226769.png)

#### 静态常量池

> 值得注意的是：从「逻辑分区」的⻆度⽽⾔「常量池」是属于「⽅法区」的，
>
> 但⾃从在「JDK7」以后，就已经把「运⾏时常量池」和「静态常量池」转移到了 「堆」内存中进⾏存储
>
> （对于「物理分区」来说「运⾏时常量池」和「静态常量池』就属于 堆）

- 静态常量池主要存储的是`字⾯量`以及`符号引⽤`等信息，静态常量池也包括 了我们说的`字符串常量池`
- **字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了**避免字符串的重复创建**。

#### 运行时常量池

- Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。
- 运行时常量池的功能**类似于传统编程语言的符号表**，尽管它包含了比典型符号表更广泛的数据。
- 「运⾏时常量池」存储的是**「类加载」时⽣成的「直接引⽤」等信息**。

#### 为什么要用元空间

- 「元空间」存储不在虚拟机中，⽽是使⽤本地内存，JVM 不会再出现⽅法区的内存溢出，以往「永久代」经常因为内存不够⽤导致跑出OOM异常。

#### 为什么常量池要移到堆中

- 主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。
- Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

# 二、HotSpot虚拟机中的对象

## 对象的创建

#### Step1:类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数**是否能在常量池中定位到这个类的符号引用**，并且检查这个符号引用代表的**类是否已被加载过**、**解析和初始化过**。如果没有，那必须先执行相应的**类加载过程**。

#### Step2:分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式** （补充内容，需要掌握）：

- 指针碰撞 ：
  - 适用场合 ：堆内存规整（即没有内存碎片）的情况下。
  - 原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
  - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表 ：
  - 适用场合 ： 堆内存不规整的情况下。
  - 原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
  - 使用该分配方式的 GC 收集器：CMS

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### Step3:初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都**初始化为零值**（**不包括对象头**），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### Step4:设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如**是否启用偏向锁**等，对象头会有不同的设置方式。

#### Step5:执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 对象的内存布局

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。

- **Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

- **实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

- **对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

## 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。

- 句柄

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为**句柄池**，reference 中存储的就是对象的句柄地址，而句柄中包含了对象**实例数据**与类型数据各自的具体地址信息。

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206160243414.png)

- 直接指针

如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问**类型数据**的相关信息，而 reference 中存储的**直接就是对象的地址**。

![](https://blogpicture2022.oss-cn-hangzhou.aliyuncs.com/202206160244040.png)

这两种对象访问方式各有优势

- 使用句柄来访问的最大好处是 reference 中存储的是**稳定的句柄地址**，在**对象被移动时只会改变句柄中的实例数据指针**，而 reference 本身不需要修改。
- 使用直接指针访问方式最大的好处就是**速度快**，它**节省了一次指针定位的时间开销**。